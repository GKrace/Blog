# 定时器

## 重复的定时器

使用 setInterval 创建定时器确保了定时器代码规则的插入队列中。这个方式的问题在于，定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿，不过 js 避免了这个问题，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中，这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。  
这种重复定时器有两个问题:  
1.某些间隔会被跳过  
2.多个定时器的代码执行之间的间隔可能会比预期的小。假设某个 onclick 事件处理程序使用 setInterval 设置了一个 200ms 间隔的重复定时器，如果事件处理程序花了 300ms 多一点的时间完成，同时定时器代码也花了差不多的时间，就会出现跳过间隔且连续运行定时器代码的情况。

> 为了避免这两个缺点，可以用如下模式使用链式 setTimeout()调用

```javascript
setTimeout(function() {
    setTimeout(argument.callee, interval);
}, interval);

function timer(func, interval) {
    setTimeout(function() {
        func();
        timer(func, interval);
    }, interval);
}
```

这个模式链式调用了 setTimeout(),每次函数执行的时候都会创建一个新的定时器，第二个 setTimeout()调用使用了 arguments.callee 来获取对当前执行函数的引用，并为其设置另一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔，而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。
