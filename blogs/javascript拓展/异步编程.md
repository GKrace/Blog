# JS异步编程六种方案

## 一.回调函数

* 优点：简单，容易理解和实现
* 缺点：不利于代码的阅读和维护，各个部分之间高度耦合，是的程序结构混乱，流程难以追踪(尤其是多个回调函数嵌套的情况)，而且每个任务只能指定一个回调函数。此外它不能使用try catch捕获错误，不能直接return

## 二.事件监听

* 优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以‘去耦合’，有利于实现模块化
* 缺点：整个程序都要变成事件驱动型，运行流程就会变得很不清晰。阅读代码的时候很难看出主流程

## 三.发布订阅

我们假定，存在一个‘信号中心’，某个任务执行完成，就向信号中心‘发布’（publish）一个信号，其他任务可以向信号中心‘订阅’（subscribe）这个信号，从未知道什么时候自己开始执行，这就叫做‘发布/订阅模式’，又称“观察者模式”。  
这种方法性质与‘事件监听’类似，但明显优于后者，因为可以通过查看‘消息中心’，了解存在多少信号，每个信号有多少订阅者，从而监控程序的运行。

## 四.Promise

* 优点：可以捕获错误，而且很好的解决了回调地狱的问题
* 缺点：无法取消Promise，错误需要通过回调函数去捕获

## 五.生成器Generators/yield

* 语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态
* **Generator函数除了状态机，还是一个遍历器对象生成函数**
* **可暂停函数，yield可暂停，next方向可启动，每次返回的是yield后的表达式结果**
* yield表达式本身没有返回值，或者说总是返回undefined，**next方法可以带一个参数，该参数就会被当做上一个yield表达式的返回值**。

## 六.async/await

**一个函数如果加上async，那么该函数会返回一个Promise**。

## 总结

1.JS异步编程进化史：callback -> promise -> generator -> async+await  
2.async/await 函数的实现，就是将Generator函数自动执行器，包装在一个函数里  
3.async/await 可以说是异步的终极解决方案了
