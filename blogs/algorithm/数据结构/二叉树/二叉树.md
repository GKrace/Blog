# 二叉树

```typescript
/*
leecode:
226.翻转二叉树（简单）
114.二叉树展开为链表（中等）
116.填充每个节点的下一个右侧节点指针（中等）
*/
```

树的问题即树的递归遍历框架：

```typescript
// 二叉树遍历框架
function traverse(root: TreeNode) {
  // 前序遍历
  traverse(root.left);
  // 中序遍历
  traverse(root.right);
  // 后序遍历
}
```

## 二叉树的重要性

**快速排序就是二叉树的前序遍历，归并排序就是二叉树的后序遍历**。

快速排序的逻辑是：若要对 nums[lo..hi]进行排序，我们先找一个分界点 p,通过交换元素使得 nums[lo..p-1]都小于等于 nums[p],且 nums[p+1..hi]都大于 nums[p],然后递归地去 nums[lo..p-1]和 nums[p+1..hi]中寻找新的分界点，最后整个数组就被排序了。

快排的框架如下：

```typescript
function sort(nums: number[], lo: number, hi: number) {
  // 前序遍历位置
  // 通过交换元素构建分界点p
  let p = partition(nums, lo, hi);
  //...

  sort(nums, lo, p - 1);
  sort(nums, p + 1, hi);
}
```

先构造分界点，然后去左右子数组构造分界点，与二叉树的前序遍历思路一致。

归并排序逻辑：若要对 nums[lo..hi]进行排序，先对 nums[lo...mid]排序，再对 nums[mid+1..hi]排序，最后把这两个有序的子数组合并，整个数组就排好序了。框架如下：

```typescript
function sort(nums: number[], lo: number, hi: number) {
  let mid = (lo + hi) / 2;
  sort(nums, lo, mid);
  sort(nums, mid + 1, hi);

  //后序遍历位置
  // 合并两个排好序的子数组
  merge(nums, lo, mid, hi);
}
```

先对左右子数组排序，然后合并（类似合并有序链表的逻辑），即二叉树后序遍历的框架,分治算法

## 递归算法的秘诀

**写递归算法的关键是要明确函数的【定义】是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节**。

例子：计算一棵二叉树共有几个节点：

```typescript
// 定义：count(root)返回root为根的树有多少节点
function count(root: TreeNode) {
  // base case
  if (root == null) return 0;
  // 自己加上子树的节点数就是整棵树的节点数
  return 1 + count(root.left) + count(root.right);
}
```

**写树相关的算法，简单说就是，先搞清楚当前 root 节点该做什么，然后根据函数定义递归调用子节点**，递归调用会让子节点做相同的事情

## 算法实践

### 反转二叉树

输入一个二叉树根节点，把整棵树镜像翻转。  
**只要把二次树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树**

```typescript
function invertTree(root: TreeNode) {
  // base case
  if (root == null) return null;

  // root 节点需要交换它的左右子节点
  let tmp = root.left;
  root.left = root.right;
  root.right = tmp;

  // 让左右子节点继续翻转他们的子节点
  invertTree(root.left);
  invertTree(root.right);
  return root;
}
```

如果把交换左右子节点的代码放在后序遍历的位置也是可以的，但是放在中序遍历的位置是不行的，因为先交换左节点 left 的子节点，在交换 left 和 right，再交换 right 的子节点（这时的 right 已经变成了 left 了）。中序遍历会导致左节点交换两次，右节点交换 0 次
