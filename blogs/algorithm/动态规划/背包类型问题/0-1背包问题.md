# 0-1 背包问题

给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

举个简单的例子，输入如下：

```typescript
(N = 3), (W = 4);
wt = [2, 1, 3];
val = [4, 2, 3];
```

算法返回 6，选择前两件物品装进背包，总重量 3 小于 W，可以获得最大价值 6。

题目就是这么简单，一个典型的动态规划问题。**这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半**。这也许就是 0-1 背包这个名词的来历。

## 动态规划套路

### 第一步要明确【状态】和【选择】

状态有两个，即【背包的容量】【可选择的物品】。  
选择也有两个【装进背包】【不装进背包】。

```typescript
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

### 第二步要明确 dp 数组的定义

dp 数组就是描述问题局面的一个数组。

首先刚才找到的状态有两个， 也就是说我们需要一个二维 dp 数组，一维表示可选择的物品，一维表示背包的容量。

**dp[i][w]定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]**.

比如 dp[3][5]=6,含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6.

**根据这个定义，我们想求的最终答案就是 dp[N][w],base case 就是 dp[0][..]=dp[..][0]=0**,因为没有物品或者背包没有空间的时候，能装的最大价值就是 0.

```typescript
dp[N+1][W+1]
dp[0][..] = 0
dp[..][0] = 0

for i of [1..N]:
    for w of [1..W]:
        dp[i][w] = max(
            把物品 i 装进背包,
            不把物品 i 装进背包
        )
return dp[N][W]
```

### 第三步根据【选择】，思考状态转移的逻辑

**这一步要结合对 dp 数组的定义和我们的算法逻辑来分析：**

先重申一下刚才我们的 dp 数组的定义：

dp[i][w]表示：对于前 i 个物品，当前背包的容量为 w 时，这种情况下可以装下的最大价值是 dp[i][w]。

**如果你没有把这第 i 个物品装入背包**，那么很显然，最大价值 dp[i][w]应该等于 dp[i-1][w]。

**如果你把这第 i 个物品装入了背包**，那么 dp[i][w]应该等于 dp[i-1]w-wt[i-1]] + val[i-1]。

首先，由于 i 是从 1 开始的，所以对 val 和 wt 的取值是 i-1.而 dp[i-1]w-wt[i-1]]是你如果想装第 i 个物品，你怎么计算这时候的最大价值？**在装第 i 个物品的前提下，背包能装的最大价值是多少**？

显然，你应该寻求剩余重量 w-wt[i-1]相纸下能装的最大价值，加上第 i 个物品的价值 val[i-1]，这就是装第 i 个物品的前提下，背包可以装的最大价值。

```typescript
function knapsack(W: number, N: number, wt: number[], val: number[]) {
  // vector全填入0，base case初始化
  const dp = Array.from({ length: N + 1 }).map((i) => {
    return Array.from({ length: W + 1 }).map((j) => 0);
  });

  for (let i = 1; i <= N; i++) {
    for (let w = 1; w <= W; w++) {
      if (w - wt[i - 1] < 0) {
        // 当前背包容量装不下，只能选择不装入背包
        dp[i][w] = dp[i - 1][w];
      } else {
        // 装入或者不装入背包，择优
        dp[i][w] = Math.max(
          dp[i - 1][w - wt[i - 1]] + val[i - 1],
          dp[i - 1][w],
        );
      }
    }
  }
}
```
