# 正则表达式匹配

这两个通配符是最常用的，其中点号「.」可以匹配任意一个字符，星号「\*」可以让之前的那个字符重复任意次数（包括 0 次）。

比如说模式串 ".a*b" 就可以匹配文本 "zaaab"，也可以匹配 "cb"；模式串 "a..b" 可以匹配文本 "amnb"；而模式串 ".*" 就比较牛逼了，它可以匹配任何文本。

给我们输入两个字符串 s 和 p，s 代表文本，p 代表模式串，请你判断模式串 p 是否可以匹配文本 s。我们可以假设模式串只包含小写字母和上述两种通配符且一定合法，不会出现 \*a 或者 b\*\* 这种不合法的模式串

点号通配符很好实现，s 中的任何符号，只要遇到.通配符，无脑匹配就完事了。\*号通配符，一旦遇到，前面的那个字符可以选择重复一次，可以重复多次，也可以一次都不出现。

对于这个问题，可以对所有可能出现的情况，全部穷举一遍，只要有一种情况可以完成匹配，就认为 p 可以匹配 s

## 思路分析

s 和 p 互相匹配的过程大致是，两个指针 i，j 分别在 s 和 p 上移动，如果最后两个指针都能移动到字符串的末尾，那么就匹配成功，反之则失败。

**正则表达算法问题只需要把住一个基本点：看两个字符是否匹配，一切逻辑围绕匹配/不匹配两种情况展开即可**。

如果不考虑\*通配符，面对两个待匹配字符 s[i]和 p[j]，我们唯一能做的就是看它俩是否匹配：

```typescript
function isMatch(s: string, p: string) {
  let i = 0,
    j = 0;
  while (i < s.length && j < p.length) {
    // . 是通配符
    if (s[i] == p[j] || p[j] == ".") {
      // 匹配，接着匹配s[i+1..]和p[j+1..]
      i++;
      j++;
    } else {
      // 不匹配
      return false;
    }
  }
}
```

如果加入\*通配符，需要分情况来分析：

**当 p[j+1]为 \* 通配符时，分情况讨论**：

- 1.如果 s[i] == p[j],有两种情况：

  - 1.1 p[i]有可能会匹配多个字符，比如 s='aaa',p='a*',那么 p[0]会通过*匹配 3 个字符"a"
  - 1.2 p[i]有可能匹配 0 个字符，比如 s="aa",p="a\*aa",由于后面的字符可以匹配 s，所以 p[0]只能匹配 0 次。

- 2.如果 s[i]!= p[j],只有一种情况：

  - p[j]只能匹配 0 次，然后看一下字符是否能和 s[i]匹配，比如说 s="aa",p="b\*aa",此时 p[0]只能匹配 0 次

```typescript
if (s[i] == p[j] || p[j] == ".") {
  // 匹配
  if (j < p.length - 1 && p[j + 1] == "*") {
    // 有*通配符，可以匹配0次或多次
  } else {
    // 无*通配符，只能匹配1次
    i++;
    j++;
  }
} else {
  // 不匹配
  if (j < p.length - 1 && p[j + 1] == "*") {
    // 有*通配符，只能匹配0次
  } else {
    // 无 * 通配符，结束匹配
    return false;
  }
}
```

现在的问题是，遇到\* 通配符时，到底应该匹配 0 次还是匹配多次？多次是几次？

这就是一个做【选择】的问题，要把所有可能的选择都穷举一遍才能得出结果，动态规划算法的核心就是【状态】和【选择】，**【状态】无非就是 i 和 j 两个指针的位置，【选择】就是 p【j】选择匹配几个字符**。

## 动态规划解法

todo
