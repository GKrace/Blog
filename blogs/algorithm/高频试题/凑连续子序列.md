# 凑连续子序列

```typescript
/*
leecode:
659. 分割数组为连续子序列（中等）
*/
```

给你输入一个升序排列的数组 nums（可能包含重复数字），请你判断 nums 是否能够被分割成若干个长度至少为 3 的子序列，每个子序列都由连续的整数组成。

比如题目举的例子，输入 nums = [1,2,3,3,4,4,5,5]，算法返回 true。

因为 nums 可以被分割成 [1,2,3,4,5] 和 [3,4,5] 两个包含连续整数子序列。

但如果输入 nums = [1,2,3,4,4,5]，算法返回 false，因为无法分割成两个长度至少为 3 的连续子序列。

类似前文 回溯算法进行集合划分，我们想把 nums 的元素划分到若干个子序列中，其实就是下面这个代码逻辑：

```typescript
for (const v of nums) {
    if(...){
        // 将v分配到某个子序列中
    }else{
        // 实在无法分配
        return false
    }
    return true
}
```

如何分配当前元素 v 呢?共有两种情况：

- **1.当前元素 v 自成一派，【以自己开头】构成一个长度至少为 3 的序列**。

比如输入 nums = [1,2,3,6,7,8]，遍历到元素 6 时，它只能自己开头形成一个符合条件的子序列 [6,7,8]。

- **2.当前元素 v 接到已经存在的子序列后面**。

比如输入 nums = [1,2,3,4,5]，遍历到元素 4 时，它只能接到已经存在的子序列 [1,2,3] 后面。它没办法自成开头形成新的子序列，因为少了个 6。

但是，如果这两种情况都可以，应该如何选择？比如说，输入 nums = [1,2,3,4,5,5,6,7]，对于元素 4，你说它应该形成一个新的子序列 [4,5,6] 还是接到子序列 [1,2,3] 后面呢？

显然，nums 数组的正确划分方法是分成 [1,2,3,4,5] 和 [5,6,7]，所以元素 4 应该优先判断自己是否能够接到其他序列后面，如果不行，再判断是否可以作为新的子序列开头。

freq 哈希表帮助一个元素判断自己是否能够作为开头，need 哈希表帮助一个元素判断自己是否可以被接到其他序列后面。

- **freq 记录每个元素出现的次数**。

比如 freq[3] == 2 说明元素 3 在 nums 中出现了 2 次。

那么如果我发现 freq[3], freq[4], freq[5] 都是大于 0 的，那就说明元素 3 可以作为开头组成一个长度为 3 的子序列。

- **need 记录哪些元素可以被接到其他子序列后面**。

比如说现在已经组成了两个子序列 [1,2,3,4] 和 [2,3,4]，那么 need[5] 的值就应该是 2，说明对元素 5 的需求为 2。

```typescript
function isPossible(nums: number[][]) {
  let freq = new Map();
  let need = new Map();
  // 统计nums中元素的频率
  for (const v of nums) {
    freq[v] = freq[v] ? freq[v] + 1 : 1;
  }

  for (const v of nums) {
    // 已经被用到其他子序列
    if (freq[v] == 0) continue;

    // 先判断v是否能接到其他子序列后面
    if (need.has(v) && need[v] > 0) {
      // v可以接到之前的某个序列后面
      freq[v]--;
      // 对v的需求减一
      need[v]--;
      // 对v+1的需求加一
      need[v + 1]++;
    } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {
      // 将v作为开头，新建一个长度为3的子序列[v,v+1,v+2]
      freq[v]--;
      freq[v + 1]--;
      freq[v + 2]--;
      // 对v+3的需求加一
      need[v + 3]++;
    } else {
      // 两种情况都不符合，则无法分配
      return false;
    }
  }
  return true;
}
```
