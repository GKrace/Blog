# React 理念

## 快速响应

React 关键目标是快速响应，快速响应的制约因素是：

- 当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。

- 发送网络请求后，由于等待数据返回才能进行下一步操作导致不能快速响应。

即：

- CPU 瓶颈

- IO 瓶颈

## CPU 瓶颈

对于一个 5000 个 DOM 的渲染，由于 GUI 渲染引擎和 JS 线程是互斥的，所以 JS 脚本执行和浏览器布局，绘制不能同时执行。  
在每 16.7ms(60Hz)时间内，需要完成以下工作：

```javascript
JS脚本执行 ------ 样式布局 ------ 样式绘制
```

当 JS 执行时间过长，超出 16.7ms，这次刷新就没有时间执行样式布局和样式绘制了

React 的解决方案是：在浏览器每一帧的时间中，预留一些时间给 JS 线程，React 利用这部分时间更新组件（源码中预留的初试时间是 5ms）。  
当预留的时间不够用时，React 将线程控制权交给浏览器使其有时间渲染 UI，React 则等待下一帧时间到来继续被中断的工作。

> 这种将长任务分拆到每一帧中，一次执行一小段任务的操作，被称为 **时间切片（time slice）**

所以解决 CPU 瓶颈的关键是实现**时间切片**，而**时间切片**的关键是：将**同步的更新**变为**可中断的异步更新**

## IO 的瓶颈

网络延迟是前端开发者无法解决的，如何在网络延迟客观存在的情况下，减少用户对网络延迟的感知？  
React 的答案是[将人机交互研究的结果整合到真实的 UI 中](https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#putting-research-into-production)

以 apple 为例：点击“通用”后的交互是同步的，直接显示后续界面，点击“siri 与搜索”后的交互是异步的，需要等待请求返回后再显示后续界面，但从用户感知来看，这两者区别微乎其微。其原理是：点击“siri 与搜索”后，现在当前页面停留一小短时间，这一小段时间被用来请求数据。

为此，React 实现了 Suspence 功能及配套的 hook---useDeferredValue,其源码实现也需要将**同步的更新**变为**可中断的异步更新**
