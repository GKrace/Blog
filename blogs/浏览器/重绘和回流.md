# 重绘和回流（Repaint Reflow）

## 浏览器的渲染过程

1.解析HTML，生成DOM树，解析CSS，生成CSSOM树  
2.将DOM树和CSSOM树结合，生成渲染树（rendner Tree）  
3.Layout(回流)：根据生成的渲染树，进行回流（Layout），得到节点的几何信息（位置，大小）  
4.Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素  
5.Display:将像素发送给GPU，展示在页面上

## 生成渲染树

1.从DOM树的根节点开始遍历每个可见节点。  
2.对于每个可见的节点，找到CSSOM树中对应的规则，并应用他们.  
3.根据每个不可见的节点以及其对应的样式，组合生成渲染树.  
不可见的节点包括：

* 一些不会渲染输出的节点，比如script，meta，link等
* 一些通过css进行隐藏的节点，比如display：none，注意，利用visiblity和opacity隐藏的节点，还是会显示在渲染树上，只有display：none的节点才不会显示在渲染树上

## 回流

前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口（viewport）的确切位置和大小，这个计算的阶段就是回流

## 重绘

我们通过构造渲染树和回流的阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置，大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点

## 何时发生回流重绘(回流一定会触发重绘，而重绘不一定会回流)

* 添加或删除可见的DOM元素
* 元素的位置发生改变
* 元素的尺寸发生变化（包括外边框，内边框，边框大小，高度和宽度等）
* 内容发生变化，比如文本或图片被另一个不同尺寸的图片所替代
* 页面一开始渲染的时候（这个无法避免）
* 浏览器的窗口尺寸变化(因为回流是根据视口的大小来计算元素的位置和大小的)

## 浏览器的优化机制

由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程，浏览器会将修改操作放入到队列中，直到过了一段时间或者操作到了一个阈值，才清空队列，但是，当你获取布局信息的操作的时候，会强制队列刷新

* offsetTop offsetLeft offsetWidth offsetHeight
* scrollTop scrollLeft scrollWidth scrollHeight
* clientTop clientLeft clientWisth clientHeight
* getComputeStyle() getBoundingClientRect

以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值，因此，**我们在修改样式的时候，最好避免使用上面列出的属性，它们都会刷新渲染队列，如果要使用它们，最好将值缓存起来**

## 减少回流和重绘

CSS

* 使用transform代替top
* 使用visibility代替display：none，因为前者只会引起重绘，后者会引发回流(改变了布局)
* 避免使用table布局，可能很小的改动会造成整个table的重新布局
* 尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响，尽可能在DOM树的最末端改变class，可以限制回流的范围，使其影响尽可能少的节点
* 避免设置多层内联样式，css选择符**从右向左匹配查找**，避免节点层级过多
* 将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，控制动画速度可以选择requestAnimationFrame
* 避免使用css表达式，可能会引发回流
* CSS3硬件加速（GPU加速），可以让transform，opacity，filters（这三个属性可以开启硬件加速）这些动画不会引起回流重绘，但是对于动画的其他属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能

JavaScript

* 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性
* 避免频繁操作DOM，创建一个documentFragment，在它上面进行所有DOM操作，最后再把它添加到文档中
* 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素以及后续元素频繁回流